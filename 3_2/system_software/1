#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable : 4996)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char copy_str(char* dest, char* src);	//srcfile에서 분리한 label을 symtab으로 옮길 때 사용하기 위한 함수 선언

typedef struct optab {	//optab 위한 구조체 선언
	char instruction[10];	//명령어
	char code[10];	//명령어 코드 (문자열 형태)
	int rcode;	//명령어 코드 (정수 형태)
}Optab;

Optab O[50] = { 0, };	//명령어와 코드를 저장할 구조체	배열 생성


typedef struct src {	//srcfile을 분리해 저장할 구조체 선언
	char Label[10];
	char Opcode[10];
	char Operand[10];
}SRC;

SRC S[50] = { 0, };	//srcfile 자료구조 저장할 구조체 배열 생성


typedef struct symtab {	//symtab을 저장할 구조체 선언
	char Label[10];
	int Loc;	//symtab label 주소 (정수 형태)
	char sLoc[10];	//symtab label 주소 (문자열 형태)
	int flag;
}SYMTAB;

SYMTAB ST[50] = { 0, };	//symtab 저장할 구조체 배열 생성


typedef struct locctr {	//locctr 구조체 
	int Loc;	//주소 (정수 형태)
}LOCCTR;

LOCCTR LT[50] = { 0, };	//locctr 저장할 구조체 배열 생성


typedef struct objectcode {	//옵젝코드 구조체
	char code[10];	//옵젝코드
}OCODE;

OCODE OC[50] = { 0, };	//옵젝코드 저장할 구조체 배열 생성


char copy_str(char* dest, char* src);	//srcfile에서 분리한 label 주소를 symtab의 label에 넘겨줄 때 사용하는 함수

int makeOpTab(FILE* ifp);	//optab 생성 함수
int seperateSrcFile(FILE* ifp);	//srcfile 자료구조로 분리 함수
int makeSymTab(int i);	//symtab 생성 함수
void makeIntFile(FILE* out, int i); //INTFILE 생성 함수
void makeObjectCode(int srcnum, int opnum, int symnum);	//옵젝코드 생성 함수
void Read(const char* fname);
void ObjFile(FILE* out, int srcnum, int opnum, int symnum);

int main() {

	char fname[200];

	printf("파일 이름 입력: ");
	scanf("%s", fname);

	Read(fname);

	return 0;
}

char copy_str(char* dest, char* src) {	//srcfile에서 분리한 label 주소를 symtab의 label에 넘겨줄 때 사용하는 함수
	while (*src) {
		*dest = *src;
		src++;
		dest++;
	}

	*dest = '\0';
}

int makeOpTab(FILE* ifp) {	//OpTab 제작 함수
	char c;
	int onum = 0, j = 0, k = 0, space = 0;
	while (1) {
		c = fgetc(ifp);
		if (feof(ifp)) {	//파일 끝까지 읽었을 경우 while 문 탈출
			O[onum].code[k] = '\0';
			O[onum].instruction[j] = '\0';
			break;
		}
		if (c == ' ') {		//띄어쓰기를 기준으로 instruction과 code 구분
			space = 1;
		}
		else if (c == '\n') {	//다음줄로 넘어갈 때 문자열 끝에 '\0' 넣어 끝부분임을 명시
			O[onum].instruction[j] = '\0';
			O[onum].code[k] = '\0';
			onum++; j = 0, k = 0;
			space = 0;
		}
		else if (space == 0) {
			O[onum].instruction[j] = c;
			j++;
		}
		else if (space == 1) {
			O[onum].code[k] = c;
			k++;
		}

		int t;
		for (t = 0; t <= onum; t++) {	//문자 형태로 저장된 16진수를 정수형으로 바꾸어 저장
			O[t].rcode = strtol(O[t].code, NULL, 16);
		}
	}

	int t;
	for (t = 0; t <= onum; t++) {	//저장한 구조체 출력
		printf("%s\t%s\t%d\n", O[t].instruction, O[t].code, O[t].rcode);
	}
	puts("");
	return onum;	//몇줄짜리 optab인지 return
}

int seperateSrcFile(FILE* ifp) {
	char c;
	int snum = 0, j = 0, k = 0, l = 0, space = 0;
	while (1) {
		c = fgetc(ifp);
		if (feof(ifp)) {	//파일 끝까지 읽었을 경우 while 문 탈출
			S[snum].Operand[l] = '\0';
			S[snum].Opcode[k] = '\0';
			S[snum].Label[j] = '\0';
			break;
		}
		if (c == ' ') {	//띄어쓰기 기준으로 label, opcode, operand 구분
			if (space == 1) {
				if (k == 0) {	//띄어쓰기 나왔을 때 opcode가 만들어진 상태인지 확인
					continue;
				}
				else {	//만들어진 경우 operand가 나올 것이므로 space 2로 변경
					space = 2;
				}
			}
			else if (space == 2) {	//연속된 띄어쓰기는 무시
				if (l == 0) {
					continue;
				}
			}
			else {	//첫 띄어쓰기인 경우 opcode가 나올 것이므로 space 1로 변경
				space = 1;
			}

		}
		else if (c == '\n') {	//다음줄로 넘어갈 때 각 문자열들 끝맺어줌
			S[snum].Operand[l] = '\0';
			S[snum].Opcode[k] = '\0';
			S[snum].Label[j] = '\0';
			snum++; j = 0, k = 0, l = 0;
			space = 0;
		}
		else if (space == 0) {	//띄어쓰기 나오기 전일 경우 label에 저장
			S[snum].Label[j] = c;
			j++;
		}
		else if (space == 1) {	//첫 띄어쓰기 이후 opcode에 저장
			S[snum].Opcode[k] = c;
			k++;
		}
		else if (space == 2) {	//opcode 저장 후 띄어쓰기 나온 경우 operand에 저장
			S[snum].Operand[l] = c;
			l++;
		}
	}

	int t;
	for (t = 0; t <= snum; t++) {	//저장한 구조체 출력
		printf("%s\t%s\t%s\n", S[t].Label, S[t].Opcode, S[t].Operand);
	}
	puts("");
	return snum;	//src 몇 줄인지 return 
}

int makeSymTab(int i) {
	int j, t, s = 0, lt = 0;
	char start[] = "start", first[] = "first", word[] = "word", byte[] = "byte";
	char resb[] = "resb", resw[] = "resw";
	//label과 operand에서 시작주소와 memory 얼마나 차지하는지 파악하기 위해 문자열 생성
	int start_loc = 0;	//시작주소 저장할 변수
	int loc = 0;	//현재 주소 저장할 변수

	for (t = 0; t <= i; t++) {

		if (S[t].Label[0] >= 'a' && S[t].Label[0] <= 'z') {	//label 이 있는 경우

			copy_str(ST[s].Label, S[t].Label);	//label 주소 symtab으로 옮겨줌

			if (0 == strcmp(S[t].Opcode, start)) {	//opcode 가 start 일 경우
				LT[lt].Loc = strtol(S[t].Operand, NULL, 16);	//16진수 사용하기 위해 strtol 사용. symtab location 에 주소 넣어줌
				ST[s].Loc = strtol(S[t].Operand, NULL, 16);	//16진수 사용하기 위해 strtol 사용. symtab location 에 주소 넣어줌
				start_loc = strtol(S[t].Operand, NULL, 16);	//시작주소 저장
				lt++, s++, t++;	//각각 다음 index로 이동
			}

			if (0 == strcmp(S[t].Label, first)) {	//label 이 first 일 경우
				ST[s].Loc = start_loc;	//주소에 시작주소 넣어줌
				LT[lt].Loc = start_loc;	//주소에 시작주소 넣어줌
				copy_str(ST[s].Label, S[t].Label);	//label 넣어줌
				loc = start_loc + 3;	//명령어 하나는 3byte
				lt++, s++;	//symtab 만 다음 index로 넘어감. srcfile은 for문을 통해 index 다음으로 넘어감
				continue;	//continue 통해 다음 루프로 넘어감
			}

			else if (0 == strcmp(S[t].Opcode, resb)) {	//opcode 가 resb 일 경우 operand byte 만큼 주소 더해줌
				ST[s].Loc = loc;
				LT[lt].Loc = loc;
				loc += strtol(S[t].Operand, NULL, 16);
				lt++, s++;
			}
			else if (0 == strcmp(S[t].Opcode, resw)) {	//opcode 가 resw 일 경우 operand * 3 byte 만큼 주소 더해줌
				ST[s].Loc = loc;
				LT[lt].Loc = loc;
				loc += 3 * strtol(S[t].Operand, NULL, 16);
				lt++, s++;
			}
			else if (0 == strcmp(S[t].Opcode, word)) {	//opcode 가 word 일 경우 3byte 만큼 더해줌
				ST[s].Loc = loc;
				LT[lt].Loc = loc;
				loc += 3;
				lt++, s++;
			}
			else if (0 == strcmp(S[t].Opcode, byte)) {	//opcode 가 byte 일 경우 operand 에서 character 명시를 위한 세글자를 제외한 나머지 byte aks
				ST[s].Loc = loc;
				LT[lt].Loc = loc;
				loc += strlen(S[t].Operand) - 3;
				lt++, s++;
			}
			else {	//일반적인 명령어의 경우 3byte 더해주고 다음 symtab index로 넘어감
				ST[s].Loc = loc;
				LT[lt].Loc = loc;
				loc += 3;
				lt++, s++;
			}
		}
		else {	//label 이 없는 경우 일반적인 명령어 3byte 더해줌
			LT[lt].Loc = loc;
			loc += 3;
			lt++;
		}

	}

	for (t = 0; t <= s - 1; t++) {
		if (ST[t].flag == 1)	//이전에 중복된 label 있어 flag 1로 변한 경우 중복 확인하지 않고 다음으로 넘어간다
			continue;
		for (j = t + 1; j <= s; j++) {	//중복 검사. 중복될 경우 두 label 다 flag 1로 바꿔준다
			if (0 == strcmp(ST[t].Label, ST[j].Label)) {
				ST[t].flag = 1;
				ST[j].flag = 1;
				break;
			}
			else
				ST[t].flag = 0;
		}
	}

	for (t = 0; t <= s - 1; t++) {
		itoa(ST[t].Loc, ST[t].sLoc, 16);
		printf("Label : %s,\tLoc : %s,\tflag : %d\n", ST[t].Label, ST[t].sLoc, ST[t].flag);
	}
	puts("");
	return s;
}

void makeIntFile(FILE* out, int i) {	//INTFILE 생성
	int t;
	for (t = 0; t <= i - 1; t++) {
		fprintf(out, "%x\t%s\t%s\t%s\n", LT[t].Loc, S[t].Label, S[t].Opcode, S[t].Operand);
	}
	for (t = 0; t <= i - 1; t++) {
		printf("%x\t%s\t%s\t%s\n", LT[t].Loc, S[t].Label, S[t].Opcode, S[t].Operand);
	}
	puts("");
}



void makeObjectCode(int srcnum, int opnum, int symnum) {	//옵젝코드 생성 함수

	int j, t;
	char start[] = "start", word[] = "word", byte[] = "byte";
	char resb[] = "resb", resw[] = "resw", end[] = "end";

	for (t = 0; t <= srcnum; t++) {

		char A[100] = { '\0' };
		int flag = 0, flag2 = 0;	//일치하는 opcode와 label 있는지 여부. 0이면 못찾은 상태

		for (int s = 0; s <= opnum; s++) {
			//opcode가 start, end, word, byte, resb, resw 일 경우 옵젝코드 설정
			if (0 == strcmp(S[t].Opcode, start)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, end)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				return;
			}
			else if (0 == strcmp(S[t].Opcode, word)) {
				for (int i = 0; i < 6 - strlen(S[t].Operand); i++) {
					strcat(OC[t].code, "0");
				}
				strcat(OC[t].code, S[t].Operand);
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, byte)) {
				int i;
				for (i = 2; i < strlen(S[t].Operand) - 1; i++) {
					sprintf(A, "%x", (int)S[t].Operand[i]);
					strcat(OC[t].code, A);
				}
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);

				break;
			}
			else if (0 == strcmp(S[t].Opcode, resb)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, resw)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}

			

			if (0 == strcmp(S[t].Opcode, strlwr(O[s].instruction))) {	//optab에서 instruction 소문자로 바꿔준 후 opcode 와 대조. instruction 찾았을 경우

				flag = 1;	//instruction 찾았음을 표시
				int length = strlen(S[t].Operand);
				for (j = 0; j <= symnum; j++) {

					if (S[t].Operand[strlen(S[t].Operand) - 2] == ',') {

						length = strlen(S[t].Operand) - 2;

					}
					if (0 == strncmp(S[t].Operand, ST[j].Label, length)) {	//instruction, label 다 찾은 경우
						char B[] = { '\0' };
						flag2 = 1;	//label 찾았음 표시
						
						strcat(OC[t].code, O[s].code);
						strcat(OC[t].code,ST[j].sLoc);
						printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
						break;
					}
					else if (j == symnum && flag2 == 0) {	//instruction은 찾았지만 label 못찾았을 경우
						strcpy(OC[t].code, "");
						printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
						puts(" **** undefined symbol in operand");
						printf("%d\n", strlen(S[t].Operand));
					}
				}
			}
			else if (s == opnum && flag == 0) {	//instruction 못 찾은 경우
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				puts(" **** undefined operation in operand");
			}
		}
	}
}

void Read(const char* fname) {

	FILE* ifp2 = fopen("optab.txt", "r");	//optab 읽기용으로 open
	FILE* OUT = fopen("INTFILE.txt", "w");	//INTFILE 쓰기용으로 open
	FILE* fp = fopen(fname, "r");

	if (fp == NULL) {
		perror("파일 열기 실패");
		exit(0);
	}

	else if (ifp2 == NULL) {	//optab 파일 없을 경우 error
		puts("파일 열기 실패");
		return 0;
	}

	else {	//파일 다 있을 경우 실행
		int opnum = makeOpTab(ifp2);
		int srcnum = seperateSrcFile(fp);	//srcfile 몇 줄인지
		puts("");
		int symnum = makeSymTab(srcnum);
		makeIntFile(OUT, srcnum);
		makeObjectCode(srcnum, opnum, symnum);
		FILE* OUT2 = fopen("OBJFILE.txt", "w");
		puts("");
		ObjFile(OUT2, srcnum, opnum, symnum);

		fclose(fp);
		fclose(OUT);
		fclose(ifp2);
	}
}

void ObjFile(FILE* out, int srcnum, int opnum, int symnum) {	//OBJFILE 생성
	int j, t;
	char start[] = "start", word[] = "word", byte[] = "byte";
	char resb[] = "resb", resw[] = "resw", end[] = "end";
	int linesize = 0;

	for (t = 0; t <= srcnum; t++) {

		char A[100] = { '\0' };

		if (0 == strcmp(S[t].Opcode, start)) {
			printf("H%s\t%06s%06x\nT", S[0].Label, S[0].Operand, LT[srcnum].Loc - LT[0].Loc);
			fprintf(out, "H%s\t%06s%06x\nT", S[0].Label, S[0].Operand, LT[srcnum].Loc - LT[0].Loc);
			break;
		}
		else if (0 == strcmp(S[t].Opcode, end)) {
			printf("\nE%06x\n", LT[0].Loc);
			fprintf(out, "\nE%06x", LT[0].Loc);
			return;
		}
		if (linesize > 30 || 0 == strcmp(S[t].Opcode, resb) || 0 == strcmp(S[t].Opcode, resw)) {
			while (0 == strcmp(S[t].Opcode, resb) || 0 == strcmp(S[t].Opcode, resw)) {
				t++;
			}
		}

		else {
			linesize += LT[t + 1].Loc - LT[t].Loc;
			int mem = t;
			for (t = mem; t <= srcnum; t++) {
				if (linesize > 30) {
					printf("%x", linesize);
					fprintf(out, "%x", linesize);
					break;
				}
				else if (0 == strcmp(S[t].Opcode, resb) || 0 == strcmp(S[t].Opcode, resw) || 0 == strcmp(S[t].Opcode, end)) {
					printf("%x", linesize);
					fprintf(out, "%x", linesize);
					break;
				}
				if (0 == strcmp(S[t].Opcode, word)) {
					for (int i = 0; i < 6 - strlen(S[t].Operand); i++) {
						strcat(OC[t].code, "0");
					}
					strcat(OC[t].code, S[t].Operand);
					printf("%s", OC[t].code);
					fprintf(out, "%s", OC[t].code);
					linesize += strlen(OC[t].code);
					break;
				}
				else if (0 == strcmp(S[t].Opcode, byte)) {
					int i;
					for (i = 2; i < strlen(S[t].Operand) - 1; i++) {
						sprintf(A, "%x", (int)S[t].Operand[i]);
						strcat(OC[t].code, A);
					}
					printf("%s", OC[t].code);
					fprintf(out, "%s", OC[t].code);
					linesize += strlen(OC[t].code);
					break;
				}
			}
		}
		printf("T%06x", LT[t]);
		linesize = 0;
		}

		for (int s = 0; s <= opnum; s++) {
			//opcode가 start, end, word, byte, resb, resw 일 경우 옵젝코드 설정
			if (0 == strcmp(S[t].Opcode, start)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, end)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				return;
			}
			else if (0 == strcmp(S[t].Opcode, word)) {
				for (int i = 0; i < 6 - strlen(S[t].Operand); i++) {
					strcat(OC[t].code, "0");
				}
				strcat(OC[t].code, S[t].Operand);
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, byte)) {
				int i;
				for (i = 2; i < strlen(S[t].Operand) - 1; i++) {
					sprintf(A, "%x", (int)S[t].Operand[i]);
					strcat(OC[t].code, A);
				}
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);

				break;
			}
			else if (0 == strcmp(S[t].Opcode, resb)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}
			else if (0 == strcmp(S[t].Opcode, resw)) {
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				break;
			}



			if (0 == strcmp(S[t].Opcode, strlwr(O[s].instruction))) {	//optab에서 instruction 소문자로 바꿔준 후 opcode 와 대조. instruction 찾았을 경우

				flag = 1;	//instruction 찾았음을 표시
				int length = strlen(S[t].Operand);
				for (j = 0; j <= symnum; j++) {

					if (S[t].Operand[strlen(S[t].Operand) - 2] == ',') {

						length = strlen(S[t].Operand) - 2;

					}
					if (0 == strncmp(S[t].Operand, ST[j].Label, length)) {	//instruction, label 다 찾은 경우
						char B[] = { '\0' };
						flag2 = 1;	//label 찾았음 표시

						strcat(OC[t].code, O[s].code);
						strcat(OC[t].code, ST[j].sLoc);
						printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
						break;
					}
					else if (j == symnum && flag2 == 0) {	//instruction은 찾았지만 label 못찾았을 경우
						strcpy(OC[t].code, "");
						printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
						puts(" **** undefined symbol in operand");
						printf("%d\n", strlen(S[t].Operand));
					}
				}
			}
			else if (s == opnum && flag == 0) {	//instruction 못 찾은 경우
				printf("%x\t%s\t%s\t%s\t%s\n", LT[t].Loc, OC[t].code, S[t].Label, S[t].Opcode, S[t].Operand);
				puts(" **** undefined operation in operand");
			}
		}
	}
}
