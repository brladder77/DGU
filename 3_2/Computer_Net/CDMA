#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>

void main(void) // 메인 함수 
{
	int i, j, k, l, m, n; // 정수형 변수 선언 
	int tx, len, row, a, b; // 정수형 변수 선언
	int** data; // data 2차원 포인터 변수 선언 
	int** chip; // chip 2차원 포인터 변수 선언 
	int** Join; // Join 2차원 포인터 변수 선언 
	int** Filter; // Filter 2차원 포인터 변수 선언 
	int c2[2][2]; // 2*2 배열 선언(chip 2단 저장) 

// Transmitter(user)와 Data 길이 입력 
	printf("-------- CDMA --------\n\n"); // 출력 
	printf("Input Transmitter (range: 2-64): "); // 출력 
	scanf("%d", &tx); // tx(User)를 입력 받음(2~64) 
	printf("\nInput Data Length : "); // 출력 
	scanf("%d", &len); // Data의 길이를 입력 받음 

// Chip Sequence Generator 
	c2[0][0] = 1; // 기본적으로 2단 chip sequence를 배열에 저장 
	c2[0][1] = 1; // chip 2단을 바탕으로 chip sequence 생성 
	c2[1][0] = 1;
	c2[1][1] = -1;
	a = (int)(log(tx+1) / log(2)); // log(2)tx+1의 값을 a에 집어넣음 
	if (pow(2, a) == tx+1) // tx+1의 수가 2^n과 같을 경우 
	{
		n = a; // n에 a의 값을 집어넣음 
		row = (int)(pow(2, n)); // row(chip 단수)에 2^n을 집어 넣음 
	}
	if (pow(2, a) != tx+1) // data수가 2^n과 다를 경우 
	{
		n = a + 1; // n에 a한 값을 넣어준다 
		row = (int)(pow(2, n)); // row(chip 단수)에 2^n을 집어 넣음 
	}
	printf("\nChip Sequence Table\n"); // 출력 
	chip = (int**)malloc(sizeof(int*) * row); // row 행의 chip 동적 배열 생성 
	for (i = 0; i < row; i++) // row 동안 반복 
	{
		chip[i] = (int*)malloc(sizeof(int) * row); // 각 행마다 row 만큼의 열 생성 
	}
	for (i = 0; i < 2; i++) // 2번 반복 
	{
		for (j = 0; j < 2; j++) // 2번 반복 
		{
			chip[i][j] = c2[i][j]; // chip sequence에 기본 2단 배열을 집어넣음 
		}
	}
	m = 1; // m=1로 초기화 
	while (m < log(row) / log(2)) // m이 log(2)row 보다 작을때 까지 반복 
	{
		b = pow(2, m); // temp2 
		for (k = 0; k < 2; k++) // 2번 반복(기본 chip sequence가 2단임) 
		{
			for (l = 0; l < 2; l++) // 2번 반복(기본 chip sequence가 2단임) 
			{
				for (i = 0; i < b; i++) // b 동안 반복 
				{
					for (j = 0; j < b; j++) // b 동안 반복 
					{
						chip[k * b + i][l * b + j] = c2[k][l] * chip[i][j]; // chip sequence 생성 
					}
				}
			}
		}
		m++; // m을 1씩 증가 시킴 
	}
	for (i = 1; i < tx+1; i++) // row 동안 반복 
	{
		for (j = 0; j < row; j++) // row 동안 반복 
		{
			printf("%4d", chip[i][j]); // chip sequence 출력 
		}
		printf("\n"); // 한줄 밑으로 내림 
	}

	// 데이터 입력 부분 
	int data1[4];
	data = (int**)malloc(sizeof(int*) * tx); // tx 행의 data 동적 배열 생성 
	for (i = 0; i < tx; i++) // tx 동안 반복 
	{
		data[i] = (int*)malloc(sizeof(int) * len); // 각 행마다 len 만큼의 열 생성 
	}
	for (i = 0; i < tx; i++) // tx 동안 반복 
	{
		data1[i] = rand() % 2?1:-1;
		for (j = 0; j < len; j++) // Len 동안 반복 
		{
			data[i][j] = data1[i]*chip[i][j]; // data 배열에 0,1을 무작위로 집어 넣음 
		}
	}
	printf("\n-------- transmitter process --------\n"); // 출력 
	for (i = 0; i < tx; i++) // tx+1 동안 반복 
	{
		printf("t%d : ", i); // 출력 
		for (j = 0; j < len; j++) // Len 동안 반복 
		{
			printf("%4d", data[i][j]); // data 배열의 내용 출력 
		}
		printf("\n"); // 한줄 밑으로 내림 
	}

	// Joining 
	int joiner = 1;
	printf("\n-------- Joiner process --------\n"); // 출력 
	Join = (int**)malloc(sizeof(int*) * row); // row 행의 동적 배열 생성 
	for (i = 0; i < row; i++) // row 동안 반복 
	{
		Join[i] = (int*)malloc(sizeof(int) * len); // 각 행마다 len 만큼의 열 생성 
	}
	for (i = 0; i < len; i++) // Len 동안 반복 
	{
		for (j = 0; j < joiner; j++) // row 동안 반복 
		{
			Join[j][i] = 0; // += 연산을 할때 이전 값이 필요하므로 0으로 초기값을 잡아줌 
			for (k = 0; k < tx; k++) // tx+1 동안 반복 
			{
				Join[j][i] += data[k][i]; // DS-CDMA Joining 
			}
		}
	}
	for (i = 0; i < joiner; i++) // row 동안 반복 
	{
		for (j = 0; j < len; j++) // Len 동안 반복 
		{
			printf("%4d", Join[i][j]); // Joining Data 출력 
		}
		printf("\n"); // 한줄 밑으로 내림 
	}

	// De-Joining 
	printf("\n-------- receiver process --------\n"); // 출력 
	Filter = (int**)malloc(sizeof(int*) * tx); // tx+1 행의 동적 배열 생성 
	for (i = 0; i < tx; i++) // tx+1 동안 반복 
	{
		Filter[i] = (int*)malloc(sizeof(int) * len); // 각 행마다 len 만큼의 열 생성 
	}
	for (i = 0; i < len; i++) // Len 동안 반복 
	{
		for (j = 0; j < tx; j++) // tx+1 동안 반복 
		{
			Filter[j][i] = 0; // += 연산을 할때 이전 값이 필요하므로 0으로 초기값을 잡아줌 
			for (k = 0; k < joiner; k++) // row 동안 반복 
			{
				Filter[j][i] += Join[k][i] * chip[j][k]; // DS-CDMA De-spreading 
			}
		}
	}
	for (i = 0; i < tx; i++) // tx+1 동안 반복 
	{
		for (j = 0; j < len; j++) // Len 동안 반복 
		{
			Filter[i][j] = Filter[i][j] / row; // 걸러낸 data를 chip sequnce로 나눠줌 
		}
	}
	for (i = 0; i < tx; i++) // tx+1 동안 반복 
	{
		printf("r%d : ", i); // 출력 
		for (j = 0; j < len; j++) // Len 동안 반복 
		{
			printf("%4d", Filter[i][j]); //표준 출력 
		}
		printf("\n"); // 한줄 밑으로 내림 
	}
	printf("\n"); // 한줄 밑으로 내림 
}
